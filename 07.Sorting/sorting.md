### Sorting
정렬은 자료구조 내에서도 상당한 중요도를 갖는 기술이다. 정렬된 자료 구조는 그렇지 않은 상태일 때보다 더 빠른 탐색 기법을 적용할 수 있게 해준다.
*  대표적으로 앞서 설명했던 Binary Search Tree, M-Way Search Tree, Topological Sort(Graph)가 있다.

### 안정 정렬 & 불안정 정렬
Sorting에서 중요한 요소 중 하나는 중복 값의 관리이다. **안정 정렬**의 경우 중복된 값을 입력한 순서와 동일하게 정렬하는 것을 의미한다. **불안정 정렬**의 경우 중복된 값이 입력 순서와 동일하지 않게 정렬될 수 있는 정렬을 의미한다.

### 제자리 정렬
Sorting에서 중요시하는 또 다른 요소로는 공간 복잡도가 있다. 제자리 정렬이란 처음 주어진 Data set이 갖는 공간만으로도 정렬이 가능한 정렬 방식을 의미한다. 제자리 정렬이 아닌 경우 정렬 하기 위해 추가적인 공간을 요구하게 된다.

#### Selection Sort
가장 단순한 정렬 방식으로, 남은 data 중 가장 작은 값을 찾고 그 값을 앞에 고정하는 방식이다.
1.  시작 idx를 0으로 지정한다(idx = 0 ~ n-1).
2.  idx부터 n-1까지 모든 값을 순차적으로 비교하며 가장 작은 값 x를 찾는다.
3.  x를 idx 위치의 값과 교환하여 data[idx] = x가 되게 한다.
4.  idx가 n-1 미만이라면 idx를 1 증가시키고 2~3을 반복한다.

##### 장점
*  가장 단순하다. 알고리즘이 직관적이라 이해가 쉽다.
*  제자리 정렬이라 공간 관리를 타이트하게 해야 할 때 유리하다.
##### 단점 
*  n개의 data를 정렬하는 데 n-1 + n-2 + ... + 1 = O(n^2)의 비용이 요구된다.<br>
*  또한 데이터가 이미 정렬되어 있더라도 O(n^2)만큼 비교 작업을 수행해야 한다. 즉 Θ(n^2)의 시간 복잡도를 갖는다. 
*  불안정 정렬이라 중복 값 사용 시 주의해야 한다.

#### Insertion Sort
인접한 두 data를 정렬하는 것을 반복하며 정렬하는 방식이다. 
1.  시작 idx를 1로 지정한다(idx = 0 ~ n-1).
2.  idx와 idx-1번째 data를 비교하고, 만약 data[idx] > data[idx-1]이라면 두 데이터를 swap한다.<br>
    2-1. 만약 idx가 1보다 크고, 2에서 swap을 했을 경우 swap한 data[idx-1]과 data[idx-2]의 정렬을 수행한다. 이후의 매 swap마다 이를 반복한다.<br>
    2-2. swap을 하지 않았다면 다음으로 넘어간다.
3.  idx가 n-1 미만이라면 idx를 1 증가시키고 2로 돌아간다.

##### 장점
*  삽입 정렬의 경우 간단하게 구현 가능하며, 레코드가 어느정도 정렬되어 있다면 작업의 수가 적다.<br>
*  최선의 경우, 즉 이미 정렬된 data일 경우엔 (n-1)번, O(n)의 비용이 요구된다.
*  안정 정렬이다. 
*  제자리 정렬이라 공간 관리를 타이트하게 해야 할 때 유리하다.
##### 단점
*  일반적인 경우 비용이 많이 드며, 최악의 경우엔 Selection Sort와 동일한 O(n^2)의 비용이 든다. <br>
*  대부분의 경우 정렬되지 않은 data에 대해 정렬을 요구하기 때문에 O(n^2)라고 보는 것이 맞다.

#### Heap Sort
data를 Heap에 담고 pop을 통해 최솟값을 뽑는 방식이다. 
1. data를 가지고 Heap을 빌드한다. 
2. Pop을 통해 구한 최댓값을 가장 뒤에 배치한다. 이렇게 배치된 최댓값은 Heap sort동안 접근 불가하게 만든다.
3. 접근 가능한 Heap data가 빌 때까지 2를 반복한다.

#### 장점
*  어떤 경우에도 O(nlog n)의 비용으로 정렬이 가능하다.
    *  heap의 설계: 단순 계산으로는 O(log n)의 삽입을 n번 수행하기에 O(nlog n)의 비용이라 표현한다. 좀 더 타이트하게 계산 시 O(n)이 나온다.
    *  heap 재조정: root의 값을 마지막 node와 바꾼 후, 바뀐 root에서 내려가면서 위치 재조정을 수행한다. 따라서 O(log n)의 비용이 든다. 이때 Pop을 n번 하기 때문에 재조정도 n번 수행되고, 따라서 총 O(nlog n)이란 비용이 heap 재조정으로 소모된다.


*  제자리 정렬이라 공간 관리를 타이트하게 해야 할 때 유리하다.
#### 단점
*  일반적인 O(nlog n)보다는 성능이 다소 떨어진다.
*  불안정 정렬이다. 

### Merge Sort
Divide and Conquer 방식으로 구현한 정렬로, 데이터를 낱개까지 쪼갠 후, 병합하면서 정렬을 수행한다.
1.  data를 절반 길이의 subData로 나눈다.
2.  subData의 길이가 1이 아니라면 1이 될때까지 1과 같은 작업을 반복한다.
3.  인접한 두 subData를 병합한다. 이때 정렬을 하며 병합을 한다.<br>
    3-1. 각 데이터는 정렬된 상태이다(첫 merge는 크기가 1이므로, 다음 merge는 정렬하며 수행되므로).<br>
    3-2. subData1, subData2의 idx를 idx1, idx2라 하면 둘 다 0으로 지정하고, subData[idx1]과 subData[idx2]를 비교한다.<br>
    3-3. 둘 중 작은 값을 mergedData에 넣고, 해당 subData의 idx를 1 증가시킨다. <br>
    3-4. mergedData가 다 찰때까지 3-2, 3-3을 반복한다.<br>
4.  병합된 mergedData가 1개가 될 때까지 3을 반복한다.
